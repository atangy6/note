[toc]
# 判断数据类型
- typeof  
typeof返回的类型都是字符串形式
不能区别：null和Object,Object和Array
使用typeof检测一个null值时，会返回object
- instanceof  判断对象的具体类型
instanceof 后面一定要是对象类型，并且大小写不能错
- ===     null/undefined
# 数据、变量与内存
## 什么是数据?
- 存储于内存中代表特定信息的'东东', 本质就是0101二进制
- 具有可读和可传递的基本特性
- 万物(一切)皆数据, 函数也是数据
- 程序中所有操作的目标都是数据（算数运算，逻辑运算，赋值，运行函数）
## 什么是内存?
- 内存条通电后产生的存储空间(临时的)
- 产生和死亡: 内存条==》通电==》产生一定容量的存储空间==>存储各种数据==>断电==>内存全部消失
- 内存的空间是临时的, 而硬盘的空间是持久的
- 分配内存: 声明变量和函数或创建对象时, JS引擎会自动为此分配一定大小的内存来存放对应的数据
-  释放内存: 清空内存中的数据, 标识内存可以再分配使用(内存不释放就不能复用)
    - 自动释放: 栈空间的局部变量
    - 垃圾回调器回调: 堆空间的垃圾对象
- 一块内存包含2个数据
    - 内部存储的数据(一般数据/地址数据)
    - 内存地址值数据
- 内存分类
    - 栈: 全局变量, 局部变量 (空间较小)
    - 堆: 对象 (空间较大)
## 什么是变量?
  * 值可以变化的量, 由变量名与变量值组成
  * 一个变量对应一块小内存, 变量名用来查找到内存, 变量值就是内存中保存的内容
## 内存，数据，变量之间的关系
- 内存是一个容器, 用来存储程序运行需要操作的数据
- 变量是内存的标识, 我们通过变量找到对应的内存, 进而操作(读/写)内存中的数据
# 对象
## 什么是对象?
- 代表现实中的某个事物, 是该事物在编程中的抽象
- 多个数据的集合体(封装体)
- 用于保存多个数据的容器
## 为什么要用对象?
便于对多个数据进行统一管理
## 对象的组成
- 属性
    - 代表现实事物的状态数据
    - 由属性名和属性值组成
    - 属性名都是字符串类型, 属性值是任意类型
- 方法
    - 代表现实事物的行为数据
    - 是特别的属性==>属性值是函数
## 什么时候必须使用['属性名']的方式
- 属性名包含特殊字符：- 空格
- 变量名不确定
# 函数
## 什么是函数
- 实现特定功能的n条语句的封装体；
- 只有函数是可执行的，其它类型的数据是不能执行；
- 函数也是对象。
## 为什么要用函数？
- 提高代码复用；
- 便于阅读和交流。
## 如何定义函数？
- 函数声明：整体会被提升到当前作用域顶部。
- 表达式：也会提升到顶部，但是只有变量名提升。
## 如何调用(执行)函数？
- test()：直接调用
- obj.test()：通过对象调用
- new test()：new 调用
- test.call/apply(obj)：临时让test成为obj的方法进行调用
## 回调函数 
### 什么函数才是回调函数？
- 用户定义的
- 用户没有直接调用
- 但最终它执行了(在某个时刻或某个条件下   在特定条件或时刻)
### 常见的回调函数？
- dom事件回调函数 ==> 发生事件的dom元素
- 定时器回调函数 ==> window
超时定时器
循环定时器
- 后面学：ajax请求回调函数、生命周期回调函数
## IIFE
### 理解
全称：Immediately-Invoked Function Expression，立即调用函数表达式
别名：立即执行函数
### 作用
- 隐藏内部实现
- 不会污染外部(全局)命名空间
- 用它来编码js模块
## this
### this是什么？
- 任何函数本质上都是通过某个对象来调用的，如果没有直接指定就是window。
- 所有函数内部都有一个变量this。
- 它的值是调用函数的当前对象。
一个关键字，一个内置的引用变量；
在函数中都可以直接使用this；
this代表调用函数的当前对象；
在定义函数时，this还没有确定，只有在执行时才动态确定(绑定)的。
- 根据调用函数的方式不同，this会指向不同的对象：

1. 以函数的形式调用，this指向window（因为，一切函数都是window的方法；call( )或apply() 通过第一个实参来指定函数中this）；
2. 以方法的形式调用，this指向方法调用的对象；
3. 以构造函数的形式调用时，this就是新创建的对象。
### 如何确定this的值？
- test()：window
- p.test()：p
- new test()：新创建的对象
- p.call(obj)：obj
# 函数高级
## 原型原型链
- 每个函数都有一个prototype属性，它默认指向一个Object实例空对象（即：原型对象）
- 原型对象中有一个属性constructor，它指向函数对象。
### 显式原型与隐式原型
- 每个函数function都有一个prototype，即显式原型（属性）
- 每个对象都有一个__proto__，可称为隐式原型（属性）
- 对象的隐式原型的值为其构造函数的显式原型的值。
### 原型链
- 访问一个对象的属性时，先在自身属性中查找， 如果找到就返回，如果没找到，沿着_ _ proto_ _这条链向上找，直到找到就返回，如果没找到，返回undefined
- 别名：隐式原型链
- 作用：查找对象属性（方法）
- Function的prototype与_ _ proto_ _是指向一个地方。
- 所有函数的_ _ proto_ _都是相等的，因为都是New Function（）创建的，都等于Function.prototype。
- 函数的显式原型指向的对象默认是空的Object实例对象（Object不满足）
- Object的原型对象是原型链尽头！（Object.prototype.__ proto__=null）
### 属性问题
- 当我们为对象设置属性的时候，是不看原型链的，如果原型链中也有此属性，在读取该属性的时候，会读取属性内部的属性而不是原型对象的属性。
- 读取对象的属性值时：会自动到原型链中寻找
- 设置对象的属性值时：不会查找原型链，如果当前对象中没有此属性，直接添加此属性并设置其值
- 方法一般定义在原型中，属性一般通过构造函数定义在对象本身上
```js
    function Fn(){
        }
       Fn.prototype.a='xxx';
       var fn1=new Fn();
    //    读取对象的属性值时：会自动到原型链中寻找
       console.log(fn1.a);//xxx
       var fn2=new Fn();
    //    设置对象的属性值时：不会查找原型链
       fn2.a='yyy';
       console.log(fn1.a,fn2.a);//xxx yyy
```
### instanceof
表达式：A instanceof B：A是否是B这个构造函数的实例对象
A：实例对象 B：构造函数
如果函数B的显式原型在A对象的原型链上，返回true，否则返回false。
## 变量提升与函数提升
- 从概念的字面意义上说，“变量提升”意味着**变量和函数的声明会在物理层面移动到代码的最前面**，但这么说并不准确。实际上变量和函数声明在代码里的位置是不会动的，而是在编译阶段被放入内存中。
- 当有多个同名变量的时候，函数声明会覆盖其他的声明。如果有多个函数声明，则由最后一个函数声明覆盖之前的所有声明。
- 函数提升优先级高于变量提升,且不会被变量声明覆盖，但会被变量赋值覆盖
```js
        if(!(b in window)){
            var b=1;
        }
        console.log(b);//undefined
        // 同
        var b
        if(!(b in window)){
            b=1;
        }
        console.log(b);

        var c = 1;
        function c(c){
            console.log(c);
        }
        c(2);//报错
        // 同
        var c
        function c(c){
            console.log(c);
        }
        c = 1;
        c(2);
```
### 为什么会有变量提升
来源：https://juejin.cn/post/7007224479218663455
## 执行上下文
### 全局执行上下文
- 在执行全局代码前将window确定为全局执行上下文
- 对全局数据进行预处理
var定义的全局变量 ===> undefined，添加为window属性
function声明的全局函数 ===> 赋值（fun），添加为window的方法
this ===> 赋值为window
- 开始执行全局代码
### 函数执行上下文
- 在调用函数，准备执行函数体之前，创建对应的函数执行上下文对象
- 对局部数据进行预处理：
形参变量 ====> 赋值（实参数据） ==> 添加为执行上下文的属性
arguments ====> 赋值（实参列表），添加为执行上下文的属性
var定义的局部变量 ===> undefined，添加为执行上下文的属性
function声明的函数 ===> 赋值（fun），添加为执行上下文的属性
this ===> 赋值（调用函数的对象）
- 开始执行函数体代码
## 作用域与作用域链
作用域就是一块"地盘"，一个代码段所在的区域
它是静态的（相对于上下文对象），在编写代码时就产生了
### 分类
全局作用域
函数作用域
块作用域（ES6）
### 作用
隔离变量，不同作用域下同名变量不会有冲突！
```js
        var obj={
            fn2:function(){
                console.log(this.fn2);
                console.log(fn2);//报错
            }
        }
        obj.fn2()
        // fn2是obj的方法，值为函数的地址值，不在函数作用域中
        // 只有全局和函数能形成作用域
        // console.log(fn2);fn2是作为一个变量来寻找的，fn2:function(){}是一个方法，而obj中没有fn2变量
```
### 作用域链
多个上下级关系的作用域形成的链，它的方向是从下向上的（从内到外），查找变量时就是沿着作用域链来查找的
### 查找一个变量的查找规则：
在当前作用域下的执行上下文中查找对应的属性，如果有就直接返回，否则进入2
在上一级作用域的执行上下文中查找对应的属性，如果有就直接返回，否则进入3
再次执行2的相同操作，直到全局作用域，如果还找不到就抛出找不到的异常
## 闭包
### 如何产生闭包？
当一个嵌套的内部（子）函数引用了嵌套的外部（父）函数的变量（函数）时，就产生了闭包
### 闭包到底是什么？
- 闭包是嵌套的内部函数
- 闭包是包含被引用变量（函数）的对象
注意：闭包存在于嵌套的内部函数在
### 产生闭包的条件
函数嵌套
内部函数引用了外部函数的数据（变量/函数）
### 闭包的作用
- 使函数内部的变量在函数执行完后，仍然存活在内存中（延长了局部变量的生命周期）
- 让函数外部可以操作（读写）到函数内部的数据（变量/函数）
### 闭包的生命周期
产生：在嵌套内部函数定义执行完时就产生了（不是在调用）
死亡：在嵌套的内部函数成为垃圾对象时
## 闭包应用：自定义JS模块
JS模块：具有特定功能的JS文件
将所有的数据和功能都封装在一个函数内部
只向外暴露一个包含n个方法的对象或函数
模块的使用者，只需要通过模块暴露的对象调用方法来实现相应功能
# 面向对象高级
## 方式1：Object构造函数模式
先创建空Object对象，然后动态添加属性、方法
使用场景：起初不确定对象内部数据
问题：语句太多
## 方式2：对象字面量模式
使用{}创建对象，同时指定属性、方法
使用场景：起初时对象内部数据是确定的
问题：如果创建多个对象，有重复代码
## 方式3：工厂模式
通过工厂函数动态创建对象并返回
使用场景：需要创建多个对象
问题：对象没有一个具体的类型，都是Object类型
## 方式4：自定义构造函数模式
自定义构造函数，通过new创建对象
使用场景：需要创建多个类型确定的对象
问题：每个对象都有相同的数据，浪费内存
## 方式5：构造函数+原型的组合模式
自定义构造函数，属性在函数中初始化，方法添加到原型上
使用场景：需要创建多个类型确定的对象
# 线程机制与事件机制
## 进程与线程
### 进程
程序的一次执行，它占有一片独有的内存空间
可以通过windows任务管理器查看进程
### 线程
是进程内的一个独立执行单元
是程序执行的一个完整流程
是CPU的最小的调度单元
### 相关知识
应用程序必须运行在某个进程的某个线程上
一个进程中至少有一个运行的线程：主线程，进程启动后自动创建
一个进程中也可以同时运行多个线程，我们会说程序是多线程运行的
一个进程内的数据可以供其中的多个线程直接共享
多个进程之间的数据是不能直接共享的
线程池（Thread Pool）：保存多个线程对象的容器，实现线程对象的反复利用
js是单线程运行的，但H5 Workers可以多线程运行
## 浏览器内核
### 模块
主线程：
- js引擎模块：负责js程序的编译与运行
- html，css文档解析模块：负责页面文本的解析
- DOM/CSS模块：负责DOM/CSS在内存中的相关处理
- 布局和渲染模块：负责页面的布局和效果的绘制（内存中的对象）
分线程：
- 定时器模块：负责定时器的管理
- 事件响应模块：负责事件的管理
- 网络请求模块：负责ajax请求
## 定时器引发的思考
### 定时器真是定时执行的吗？
定时器并不能保证真正定时执行
一般会延迟一丁点（可以接受），也有可能延迟很长时间（不能接受）
### 定时器回调函数是在分线程执行的吗？
在主线程执行的，js是单线程的
## JS是单线程执行的
### 如何证明js执行时单线程的？
setTimeout（）的回调函数是在主线程执行的
定时器回调函数只有在运行栈中的代码全部执行完之后才有可能执行
### 为什么js要用单线程模式，而不是多线程模式？
Javascript的单线程，与它的用途有关作为，浏览器脚本语言，Javascript的主要用途是与用户交互，以及操作DOM，这决定了它只能是单线程，否则会带来很复杂的同步问题。
### 代码的分类
初始化代码
回调代码
### js引擎执行代码的基本流程
先执行初始化代码：包含一些特别的代码，比如设置定时器、绑定事件监听、发送ajax请求
后面在某些时刻才会执行回调代码